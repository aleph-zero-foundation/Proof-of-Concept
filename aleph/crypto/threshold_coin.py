from .signatures.threshold_signatures import generate_keys

from charm.core.math.pairing import hashPair
from base64 import decodebytes


class ThresholdCoin:

    def __init__(self, dealer_id, n_processes, threshold, validation_key, secret_key):
        """
        :param int dealer_id: identification number of a process dealing this coin, from 0 to n-1
        :param int n_processes: number of processes
        :param int threshold: number of shares required to toss the coin
        :param validation_key: key for combining shares
        :param secret_key: key for generating a share of a coin toss
        """
        self.dealer_id = dealer_id
        self.n_processes = n_processes
        self.threshold = threshold
        self.validation_key = validation_key
        self.secret_key = secret_key

    def create_share(self, nonce):
        """
        :param int nonce: nonce for the share
        :returns: a tuple (dealer_id, nonce, coinshare)
        """
        msg_hash = self.validation_key.hash_fct(str(nonce))
        share = self.secret_key.generate_share(msg_hash)

        return (self.dealer_id, nonce, share)


    def combine_shares(self, shares):
        """
        :param dict shares: keys are processes ids, values are shares (tuples (dealer_id, nonce, coinshare))
        :param int nonce: nonce for the coin
        :returns: bool
        """
        # there are enough shares of a coin
        assert len(shares) == self.threshold
        # all shares are generated for the same nonce
        assert len(set([nonce for _, nonce, _ in shares.values()])) == 1
        # shares are generated by keys generated by self.dealer_id
        assert [None for dealer_id, _, _ in shares.values() if dealer_id != self.dealer_id] == []

        _shares = {i: share for i, (_, _, share) in shares.items()}

        # return first bit
        signature = self.validation_key.combine_shares(_shares)
        # the test shows that 41 gives uniform distribution of coin tosses
        # TODO check what's going on
        coin_value = decodebytes(hashPair(signature))[41] % 2

        return coin_value
