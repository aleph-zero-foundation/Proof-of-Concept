from charm.core.math.pairing import hashPair
from base64 import decodebytes
from random import randrange



class ThresholdCoin:

    def __init__(self, dealer_id, process_id, n_processes, threshold, secret_key, verification_key):
        """
        :param int dealer_id: identification number of a process dealing this coin, from 0 to n-1
        :param int process_id: identification number of a process using this coin
        :param int n_processes: number of processes
        :param int threshold: number of shares required to toss the coin
        :param verification_key: key for combining shares
        :param secret_key: key for generating a share of a coin toss
        """
        self.dealer_id = dealer_id
        self.process_id = process_id
        self.n_processes = n_processes
        self.threshold = threshold
        self.secret_key = secret_key
        self.verification_key = verification_key


    def check_validity(self):
        '''
        Checks if this threshold coin is valid.
        '''

        msg_hash = self.verification_key.hash_fct(str(randrange(0,1000)))
        coin_share = self.secret_key.generate_share(msg_hash)

        return self.verification_key.verify_share(coin_share, self.process_id, msg_hash)


    def create_coin_share(self, nonce):
        """
        :param int nonce: nonce for the coin share
        :returns: coin share for the nonce
        """
        msg_hash = self.verification_key.hash_fct(str(nonce))
        coin_share = self.secret_key.generate_share(msg_hash)

        return coin_share


    def verify_coin_share(self, coin_share, process_id, nonce):
        '''
        :param CoinShare coin_share: coin_share which validity is checked
        :param int process_id: identification number of a process that generated the coin_share
        :param int nonce: nonce for which the coin_share was generated
        :returns: True if coin_share is valid and False otherwise
        '''
        # TODO there is alternative implementation based on RSA that supports checking if
        # the coin share was generated by a particular process

        msg_hash = self.verification_key.hash_fct(str(nonce))

        return self.verification_key.verify_share(coin_share, process_id, msg_hash)


    def combine_coin_shares(self, shares):
        """
        Assumes that all shares are valid.
        :param dict shares: keys are processes ids, values are shares (tuples (dealer_id, nonce, coin_shares))
        :returns: bool
        """
        # there are enough shares of a coin
        assert len(shares) == self.threshold

        # return first bit
        signature = self.verification_key.combine_shares(shares)

        # the test shows that 41 gives uniform distribution of coin tosses
        # TODO check what's going on
        coin_value = decodebytes(hashPair(signature))[41] % 2

        return coin_value
