from charm.toolbox.pairinggroup import PairingGroup, ZR, G1, G2, pair
from functools import reduce


def generate_keys(n_parties, threshold):
    '''
        Generates one verification key and n_parties secret keys.
        :param int n_parties: number of parties that need secret keys
        :param int threshold: number of signature shares required for generating a signature
    '''

    # TODO check if this is following setup is optimal
    group = PairingGroup('MNT224')

    # pick a generator of the group
    gen = group.hash('gengen', G2)
    gen.initPP()

    ONE = group.random(ZR, seed=60)*0+1  # <-- what is that?

    # pick a set of coefficients
    coef = group.random(ZR, threshold)
    secret = coef[-1]

    # generate secret keys
    sks = [_poly(coef, x) for x in range(1, n_parties+1)]

    # generate underlying verification keys
    vk = gen ** secret
    vks = [gen ** scr for scr in sks]

    def _hash_fct(msg):
        return group.hash(msg, G1)

    # Lagrange polynomial
    def _L(S, i):
        S = sorted(S)
        num = reduce(lambda x, y: x*y, [0 - j - 1 for j in S if j != i], ONE)
        den = reduce(lambda x, y: x*y, [i - j     for j in S if j != i], ONE)
        return num/den

    verification_key = VerificationKey(threshold, _hash_fct, _L, vk, vks, gen)
    secret_keys = [SecretKey(sk) for sk in sks]

    return verification_key, secret_keys

class VerificationKey():
    '''
    An object used for verifying shares and signatures and for combining shares into signatures.
    '''

    def __init__(self, threshold, hash_fct, L, vk, vks, gen):
        '''
        :param int threshold: number of signature shares needed to generate a signature
        :param function hash_fct: function for hashing messages
        :param function L: Lagrange operator for polynomial interpolation
        :param int vk: global verification key
        :param list vks: verification keys corresponding to secret keys of all parties
        :param int gen: generator of the G2 group
        '''
        self.threshold = threshold
        self.hash_fct = hash_fct
        self.L = L
        self.vk = vk
        self.vks = vks
        self.gen = gen

    def verify_share(self, share, i, msg_hash):
        '''
        Verifies if a share generated by i-th party is valid.
        :param int share: share of a signature of a hash of a message
        :param int i: index number of a party
        :param int msg_hash: hash of a message that is signed
        '''
        return pair(share, self.gen) == pair(msg_hash, self.vks[i])

    def verify_signature(self, signature, msg_hash):
        '''
        Verifies if signature is valid.
        :param int signature: signature of msg_hash to be chacked
        :param int msg_hash: hash of a message corresponding to signature.
        '''
        return pair(signature, self.gen) == pair(msg_hash, self.vk)

    def combine_shares(self, shares):
        '''
        Combines shares into a signature of a message.
        :param list shares: shares of a signature to be produced
        '''
        assert len(shares) == self.threshold
        R = shares.keys()
        return reduce(lambda x,y: x*y, [share ** self.L(R, i) for i, share in shares.items()], 1)

    def hash_msg(self, msg):
        '''
        Hashes a message before signing.
        :param bytes msg: message to be hashed
        '''
        return self.hash_fct(msg)

class SecretKey():
    '''
    An object used for generating shares of a signature of a message.
    '''
    def __init__(self, sk):
        '''
        :param int sk: secret used for signing
        '''
        self.sk = sk

    def generate_share(self, msg_hash):
        '''
        Generates a share of a signature of a hash of a message.
        :param int msg_hash: hash of a message which signature share is generated
        '''
        return msg_hash ** self.sk

def _poly(coefs, x):
    '''
    Evaluates a polynomial given by coefficients at some point.
    :param list coefs: list of coefficients
    :param int x: evaluation point
    '''
    return reduce(lambda y, coef: x*y+coef, coefs, 0)
